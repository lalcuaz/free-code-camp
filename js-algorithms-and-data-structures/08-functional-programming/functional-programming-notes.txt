functional programming principles 
- don't alter a variable or object, create new variables and objects and return them if need be from a function.
- declare function parameters. any computation inside a function depends only on the args passed to the function, and not on any global object or variable

callbacks
functions that are slipped or passed into another function to decide the invocation of that function.

first-class functions
Functions that can be assigned to a variable, passed into another function, or returned from another function just like any other normal value. in js all functions are first class

higher-order functions
The functions that take a function as an argument, or return a function as a return value

lambda
when functions are passed in to or returned from another function, the functions passed in or returned can be called lambda

Array.prototype.map()
- iterates over each item in an array and returns a new array containing the results of calling the callback function on each element. no mutations on the original array
when the callback is used, it is passed three args. the first arg is the current element being processed. the second is the index of that element. the third is the array upon which the map method was called.
const users = [
  { name: 'John', age: 34 },
  { name: 'Amy', age: 20 },
  { name: 'camperCat', age: 10 }
];

const names = users.map(user => user.name);
console.log(names);

const ratings = watchList.map((item) => ({
  title: item["Title"],
  rating: item["imdbRating"],
}));

Array.prototype.filter()
- calls a function on each element of an array and returns a new array containing only the elements for which that function returns true.
the callback func accepts 3 args. 1st is the current element being processed. the 2nd is the index of that element. the third is the array upon which the filter method was called.
const usersUnder30 = users.filter(user => user.age < 30);

.concat()
- method for both strings and arrays. For arrays, it is called on an array then another is provided as the argument. It returns a new array and does not mutate either of the original arrays.
- push mutates the original array while concat returns a new array and leaves the original array untouched. use concat for no mutations.

.reduce()
- array processing. iterates over each item in ana array and returns a single value achieved via a callback function this is called on each iteration.
- callback accepts 4 args: the accumulator, which gets assigned the return value of the callback func from the previous iteration. the current element being processed. the index of that element. the array upon which reduce is called. 
const users = [
  { name: 'John', age: 34 },
  { name: 'Amy', age: 20 },
  { name: 'camperCat', age: 10 }
];

const sumOfAges = users.reduce((sum, user) => sum + user.age, 0);
console.log(sumOfAges);

const usersObj = users.reduce((obj, user) => {
  obj[user.name] = user.age;
  return obj;
}, {});
console.log(usersObj);

.sort()
- the sort method sorts the elements of an array according to the callback function. default sorting method is by string unicode point value so it is encourages to provide a callback function to specify how to sort the array items (normally called compareFunction(a, b)). sorted according to the return value of the compare function. return less than 0, a will come before b. greater than 0, b before a. equal to 0, remain unchanged.

function ascendingOrder(arr) {
  return arr.sort(function(a, b) {
    return a - b;
  });
}

ascendingOrder([1, 5, 2, 3, 4]);
would return [1, 2, 3, 4, 5].

function reverseAlpha(arr) {
  return arr.sort(function(a, b) {
    return a === b ? 0 : a < b ? 1 : -1;
  });
}

reverseAlpha(['l', 'h', 'z', 'b', 's']);
would return ['z', 's', 'l', 'h', 'b']